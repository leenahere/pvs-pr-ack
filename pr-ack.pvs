pr_ack: THEORY
BEGIN
IMPORTING structures@arrays, structures@for_iterate

% TYPE DEFINITIONS AND HELPER FUNCTIONS
% ################################################################################

% Type aliases
nat_args(k: nat): TYPE+ = ArrayOf[k][nat]
rfunc(k: nat): TYPE+ = [nat_args(k) -> nat]

% Array helper functions
copy_init(k: nat, l: upto(k))(a: nat_args(k)): nat_args(l)
  = LAMBDA (i: Index[l]): a(i)

init_nats(k: nat): nat_args(k) = LAMBDA (i: Index[k]): 0

% Besser: Mit fold schreiben
all_of?[T: TYPE](k: nat)(a: ArrayOf[k][T], p: [T -> bool]): bool
  = IF k = 0
    THEN TRUE
    ELSE
      for[bool]
      (0, k-1, TRUE, (LAMBDA (i: subrange(0, k-1), b: bool): b AND p(a(i))))
    ENDIF

% PRIMITIVE RECURSIVE FUNCTION DEFINITIONS
% ################################################################################

% Base functions
zero(k: nat)(a: nat_args(k)): nat = 0

pr_succ(a: nat_args(1)): nat = a(0) + 1

pi(k: posnat, i: subrange(1, k))(a: nat_args(k)): nat = a(i-1)

% Operators
% -------------------------------------------------------------------------------

% Composition
comp_build_m(r: nat, k: nat)(h: ArrayOf[r][rfunc(k)], n: nat_args(k)): nat_args(r)
  = for[nat_args(r)]
    (0, r-1, init, LAMBDA(i: subrange(0, r-1), m: nat_args(r)):
      m WITH [i := h(i)(n)])

compose(r: nat, k: nat)(g: rfunc(r), h: ArrayOf[r][rfunc(k)]):
  rfunc(k) = (LAMBDA (n: nat_args(k)): g(comp_build_m(r, k)(h, n)))

% -------------------------------------------------------------------------------

% Primitive Recursion
pr(k: nat, g:rfunc(k), h:rfunc(k+2))(n: nat_args(k+1)): RECURSIVE nat
  = IF
      n(k) = 0
    THEN
      IF k = 0 THEN g(init) ELSE g(copy_init(k+1, k)(n)) ENDIF
    ELSE
       LET m = n WITH [k := n(k)-1]
       IN h(m WITH [(k+1) |-> pr(k, g, h)(m)])
    ENDIF MEASURE n(k)

% -------------------------------------------------------------------------------


% EXAMPLES: ARITHMETIC FUNCTIONS AS PR-FUNCTIONS
% ################################################################################

% ADDITION
% -------------------------------------------------------------------------------

% PR-Arguments g, h
g_add: rfunc(1) = pi(1, 1)
% Typechecker stuerzt ab, wenn init_with inline in h gemacht wird
pi_arr_add: ArrayOf[1][rfunc(3)] = init_with[1][rfunc(3)](pi(3, 3)) 
h_add: rfunc(3) = compose(1, 3)(pr_succ, pi_arr_add)

% PR-Addition
pr_add_arr(n: nat_args(2)): nat = pr(1, g_add, h_add)(n)
pr_add(n: nat, m: nat): nat = pr_add_arr(init_nats(2) WITH [0 := n, 1 := m])

% Lemmata and Theorems
addition_args: LEMMA
  FORALL (j: nat): (FORALL (n: nat): (FORALL (m: nat):
     init_nats(2) WITH [0 := n, 1 := j] = (init_nats(2) WITH [0 := n, 1 := m]) WITH [1 := j]
  ))

arr_helper_lemma: LEMMA
  FORALL (a: nat_args(2)):
    a(1) > 0 IMPLIES (a WITH [1 := a(1)-1]) = (init_nats(2) WITH [0 := a(0), 1 := a(1) - 1])

pr_add_is_addition: FORMULA
  FORALL (n: nat): (FORALL (m: nat): pr_add(n, m) = n + m)

pr_add_arr_is_addition: FORMULA
  FORALL (a: nat_args(2)): pr_add_arr(a) = a(0) + a(1)

% MULTIPLICATION
% -------------------------------------------------------------------------------

g_mult: rfunc(1) = zero(1)
pi_arr_mult: ArrayOf[2][rfunc(3)] = init_with[2][rfunc(3)](pi(3,1)) WITH [1 := pi(3,3)]
h_mult: rfunc(3) = compose(2, 3)(pr_add_arr, pi_arr_mult)
pr_mult(n: nat, m: nat): nat = pr(1, g_mult, h_mult)(init_nats(2) WITH [0 := n, 1 := m])


pr_mult_is_multiplication: FORMULA
   FORALL (n: nat): (FORALL (m: nat): pr_mult(n, m) = n * m)


% DEFINITION: SET OF PRIMITIVE RECURSIVE FUNCTIONS
% ################################################################################

% k-ary PR-Functions predicate
prim_rec?(k: nat)(f: rfunc(k)): INDUCTIVE bool =
     (f = zero(k))
  OR (k = 1 AND f = pr_succ)
  OR (EXISTS (i: subrange(1, k)): f = pi(k, i))
%  OR (EXISTS (r: nat): (EXISTS (g: rfunc(r)): (EXISTS (h: ArrayOf[r][rfunc(k)]):
%       prim_rec?(r)(g)
%       AND all_of?[rfunc(k)](r)(h, prim_rec?(k))
%       AND f = compose(r, k)(g, h))))
  OR ((k > 0) AND (EXISTS (g: rfunc(k-1)): (EXISTS (h: rfunc(k+1)):
     prim_rec?(k-1)(g) AND prim_rec?(k+1)(h) AND f = pr(k-1, g, h))))

%prim_rec(k: nat): TYPE+ = (prim_rec?(k))

%prim_rec_preds: setofsets = {p | EXISTS (k: nat): p = prim_rec?(k)}

%test: TYPE = { (x: nat) | x = 3 }

%prim_rec: TYPE+ = { (FORALL (k: nat): (f: rfunc(k)) | prim_rec?(k)(f)) }



%PREC: TYPE+
%zero_in_prec: AXIOM


END pr_ack
