pr_ack: THEORY
BEGIN

  % ASSUMING
   % assuming declarations
  % ENDASSUMING

IMPORTING structures@arrays, structures@for_iterate

% Type aliases
nat_args(k: nat): TYPE+ = ArrayOf[k][nat]
rfunc(k: nat): TYPE+ = [nat_args(k) -> nat]

% Array helpers
sub_args(k: nat, u: below(k), l: below(u+1))(a: nat_args(k)): nat_args(u-l)
  = IF
      u = l
    THEN
      init
    ELSE
      for[nat_args(u-l)]
      (0, u-l-1, init, LAMBDA(i: subrange(0, u-l-1), m: nat_args(u-l)):
        m WITH [`i := a(i+l)])
    ENDIF

expand_args(k: nat, j: nat)(a: nat_args(k)): nat_args(k+j)
  = for[nat_args(k+j)]
    (0, k, init, LAMBDA(i: subrange(0, k-1), r: nat_args(k)):
      r WITH [`i := a(i)])

% Base functions
zero(k: nat)(a: nat_args(k)): nat = 0

succ(a: nat_args(1)): nat = a(0) + 1

pi(k: nat, i: below(k))(a: nat_args(k)): nat = a(i)

% Operators

% for loop
% n: ArrayOf[k][nat]
% h: ArrayOf[r][rfunc(k)]
% m: ArrayOf[r][nat] = {0, ..., 0}
% for(i=1; i<= n; i++) {
%   m(i-1) = h(i-1)(n)
% }

% COMPOSITION
comp_build_m(r: nat, k: nat)(h: ArrayOf[r][rfunc(k)], n: nat_args(k)): nat_args(r)
  = for[nat_args(r)]
    (0, r-1, init, LAMBDA(i: subrange(0, r-1), m: nat_args(r)):
      m WITH [`i := h(i)(n)])

compose(r: nat, k: nat)(g: rfunc(r), h: ArrayOf[r][rfunc(k)]):
  rfunc(k) = (LAMBDA (n: nat_args(k)): g(comp_build_m(r, k)(h, n)))

% PRIMITIVE RECURSION OPERATOR

% for loop
% ns: ArrayOf[k+1][nat]
% m: ArrayOf[k][nat] = {0, ..., 0}
% for(i=0; i<=k-1; i++) {
%  m(i) = ns(i)
% }

%pr_build_g_m(k: nat)(ns: nat_args(k+1)): nat_args(k)
%  = for[nat_args(k)]
%    (0, k-1, init, LAMBDA(i: subrange(0, k-1), m: nat_args(k)):
%    	m WITH [`i := ns(i)])
pr_build_g_m(k: nat)(n: nat_args(k+1)): nat_args(k)
  = sub_args(k+1, k-1, 0)(n)

% Inline in pr machen, ansonsten muss ns(i) > 0 vorausgesetzt werden (dort ist es gegeben)
%pr_build_h_m(k: nat)(ns: nat_args(k+1), f_prev: nat): nat_args(k+2)
%  = for[nat_args(k+2)]
%    (0, k, init, LAMBDA(i: subrange(0, k), m: nat_args(k+2)):
%    	m WITH [`i :=
%	  IF i = k
%	     THEN f_prev
%	  ELSIF i = k-1
%	     THEN ns(i)-1
%	     ELSE ns(i)
%	  ENDIF])

%pr_build_h_m(k: nat)(n: nat_args(k+1), f_prev: nat): nat_args(k+2)
%  = expand_args(k+1, 1)(n) WITH [`k := n(k)-1] WITH [LET j := k+1 IN [`j := f_prev]]


%pr(k: nat, g: rfunc(k), h: rfunc(k+2)): RECURSIVE rfunc(k+1)
%  = (LAMBDA (ns: ArrayOf[k+1][nat]):
%    IF ns(k) = 0
%    THEN g(pr_build_g_m(k)(ns))
%    ELSE h(pr_build_h_m(k)(ns, pr(k, g, h)(ns WITH [`k := ns(k)-1]))) ENDIF)
%MEASURE ns(k)

END pr_ack
