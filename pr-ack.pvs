pr_ack: THEORY
BEGIN
IMPORTING structures@arrays, structures@max_array

% TYPE DEFINITIONS AND HELPER FUNCTIONS
% ################################################################################

% Type aliases
nat_args(k: nat): TYPE+ = ArrayOf[k][nat]
rfunc(k: nat): TYPE+ = [nat_args(k) -> nat]

% Custom array init functions
% - These are defined here because the structures@arrays builtin
%   initializer functions sometimes crash the typechecker
copy_init(k: nat, l: upto(k))(a: nat_args(k)): nat_args(l)
  = LAMBDA (i: Index[l]): a(i)

copy_init_rfunc(r: nat, l: upto(r), k: nat)(a: ArrayOf[r][rfunc(k)]): ArrayOf[l][rfunc(k)]
  = LAMBDA (i: Index[l]): a(i)

init_nats(k: nat): nat_args(k) = LAMBDA (i: Index[k]): 0

max_nats(k: nat)(a: nat_args(k)): nat =
  IF k = 0
  THEN 0
  ELSE max[k, nat, <=](a)
  ENDIF

init_rfuncs(r: nat, k: nat): ArrayOf[r][rfunc(k)]
  = LAMBDA (i: Index[r]): LAMBDA (n: nat_args(k)): 0

% PRIMITIVE RECURSIVE FUNCTION DEFINITIONS
% ################################################################################

% Base functions
zero(k: nat)(a: nat_args(k)): nat = 0

pr_succ(a: nat_args(1)): nat = a(0) + 1

pi(k: posnat, i: subrange(1, k))(a: nat_args(k)): nat = a(i-1)

% Operators
% -------------------------------------------------------------------------------

% Composition
compose(r: posnat, k: nat)(g: rfunc(r), h: ArrayOf[r][rfunc(k)]):
  rfunc(k) = (LAMBDA (n: nat_args(k)): g(LAMBDA (i: Index[r]): h(i)(n)))

% -------------------------------------------------------------------------------

% Primitive Recursion
pr(k: nat, g:rfunc(k), h:rfunc(k+2))(n: nat_args(k+1)): RECURSIVE nat
  = IF
      n(k) = 0
    THEN
      IF k = 0 THEN g(init) ELSE g(copy_init(k+1, k)(n)) ENDIF
    ELSE
       LET m = n WITH [k := n(k)-1]
       IN h(m WITH [(k+1) |-> pr(k, g, h)(m)])
    ENDIF MEASURE n(k)

% -------------------------------------------------------------------------------


% EXAMPLES: ARITHMETIC FUNCTIONS AS PR-FUNCTIONS
% ################################################################################

% ADDITION
% -------------------------------------------------------------------------------

% PR-Arguments g, h
g_add: rfunc(1) = pi(1, 1)
% Typechecker crashes if h is initialized inline by init_with
h_add_pi_arr: ArrayOf[1][rfunc(3)] = init_with[1][rfunc(3)](pi(3, 3)) 
h_add: rfunc(3) = compose(1, 3)(pr_succ, h_add_pi_arr)

% PR-Addition
pr_add_arr(n: nat_args(2)): nat = pr(1, g_add, h_add)(n)
pr_add(n: nat, m: nat): nat = pr_add_arr(init_nats(2) WITH [0 := n, 1 := m])

% Lemmata and Theorems
addition_args: LEMMA
  FORALL (j: nat): (FORALL (n: nat): (FORALL (m: nat):
     init_nats(2) WITH [0 := n, 1 := j] = (init_nats(2) WITH [0 := n, 1 := m]) WITH [1 := j]
  ))

arr_helper_lemma: LEMMA
  FORALL (a: nat_args(2)):
    a(1) > 0 IMPLIES (a WITH [1 := a(1)-1]) = (init_nats(2) WITH [0 := a(0), 1 := a(1) - 1])

pr_add_is_addition: FORMULA
  FORALL (n: nat): (FORALL (m: nat): pr_add(n, m) = n + m)

pr_add_arr_is_addition: FORMULA
  FORALL (a: nat_args(2)): pr_add_arr(a) = a(0) + a(1)

% MULTIPLICATION
% -------------------------------------------------------------------------------

g_mult: rfunc(1) = zero(1)
pi_arr_mult: ArrayOf[2][rfunc(3)] = init_with[2][rfunc(3)](pi(3,1)) WITH [1 := pi(3,3)]
h_mult: rfunc(3) = compose(2, 3)(pr_add_arr, pi_arr_mult)
pr_mult(n: nat, m: nat): nat = pr(1, g_mult, h_mult)(init_nats(2) WITH [0 := n, 1 := m])


pr_mult_is_multiplication: FORMULA
   FORALL (n: nat): (FORALL (m: nat): pr_mult(n, m) = n * m)


% DEFINITION: SET OF PRIMITIVE RECURSIVE FUNCTIONS
% ################################################################################

% k-ary PR-Functions predicate
prim_rec?(k: nat)(f: rfunc(k)): INDUCTIVE bool =
     (f = zero(k))
  OR (k = 1 AND f = pr_succ)
  OR (EXISTS (i: subrange(1, k)): f = pi(k, i))
  OR (EXISTS (r: posnat): (EXISTS (g: rfunc(r)): (EXISTS (h: [Index[r] -> rfunc(k)]):
       prim_rec?(r)(g)
       AND (FORALL (i: Index[r]): prim_rec?(k)(h(i)))
       AND f = compose(r, k)(g, h))))
  OR ((k > 0) AND (EXISTS (g: rfunc(k-1)): (EXISTS (h: rfunc(k+1)):
     prim_rec?(k-1)(g) AND prim_rec?(k+1)(h) AND f = pr(k-1, g, h))))

prim_rec(k: nat): TYPE+ = (prim_rec?(k)) CONTAINING zero(k)

%prim_rec_preds: setofsets = {p | EXISTS (k: nat): p = prim_rec?(k)}

%test: TYPE = { (x: nat) | x = 3 }

%prim_rec: TYPE+ = { (FORALL (k: nat): (f: rfunc(k)) | prim_rec?(k)(f)) }

%PREC: TYPE+
%zero_in_prec: AXIOM


% ACKERMANN FUNCTION
% ################################################################################

% FUNCTION DEFINITION
% -------------------------------------------------------------------------------

ack(x: nat, y: nat): RECURSIVE nat =
  IF x = 0
  THEN y + 1
  ELSIF y = 0
  THEN ack(x-1, 1)
  ELSE ack(x-1, ack(x, y-1))
  ENDIF MEASURE lex2(x, y)


% LEMMATA
% -------------------------------------------------------------------------------

% Prop 4: y < A(x, y)
% ----------------------------------------------
ack_prop4: LEMMA
  FORALL (x: nat): FORALL (y: nat): y < ack(x, y)

% Prop 5: Monotonicity in y
%   y < y_ => A(x, y) < A(x, y_)
% ----------------------------------------------
ack_prop5_base: LEMMA
  FORALL (x: nat): FORALL (y: nat): ack(x, y) < ack(x, y + 1)

ack_prop5_diff: LEMMA
  FORALL (d: nat): FORALL (x, y, y_: nat): y_ = y + (d + 1) IMPLIES ack(x, y) < ack(x, y_)

ack_prop5: LEMMA
  FORALL (x: nat): FORALL (y: nat): FORALL (y_: nat): y < y_ IMPLIES ack(x, y) < ack(x, y_)

% Prop 6: A(x, y+1) <= A(x+1, y)
% ----------------------------------------------
ack_prop6: LEMMA
  FORALL (x: nat): FORALL (y: nat): ack(x, y + 1) <= ack(x + 1, y) 

% Prop 7: Monotonicity in x
%   x < x_ => A(x, y) < A(x_, y)
% ----------------------------------------------
ack_prop7_base: LEMMA
  FORALL (x: nat): FORALL (y: nat): ack(x, y) < ack(x + 1, y)

ack_prop7_diff: LEMMA
  FORALL (d: nat): FORALL (x, x_, y: nat): x_ = x + (d + 1) IMPLIES ack(x, y) < ack(x_, y)

ack_prop7: LEMMA
  FORALL (x: nat): FORALL (x_: nat): FORALL (y: nat): x < x_ IMPLIES ack(x, y) < ack(x_, y)

% Prop 8: A(1, y) = y + 2
% ----------------------------------------------
ack_prop8: LEMMA
  FORALL (y: nat): ack(1, y) = y + 2

% Prop 9: A(2, y) = 2y + 3
% ----------------------------------------------
ack_prop9: LEMMA
  FORALL (y: nat): ack(2, y) = 2 * y + 3

% Prop 10: EXISTS k: A(x, A(x_, y)) < A(k, y)
% ----------------------------------------------
ack_prop10: LEMMA
  FORALL (x, x_: nat): EXISTS (k: nat): FORALL (y: nat): ack(x, ack(x_, y)) < ack(k, y)


% THEOREMS
% -------------------------------------------------------------------------------

% Majorization Theorems
% ----------------------------------------------

% nat_args version of the Ackermann function
ack_arr(n: nat_args(2)): nat = ack(n(0), n(1))

% FORALL f in PR: EXISTS c: FORALL n:
%   f(n) < A(c, max(n))
pr_maj_by_ack: THEOREM
  FORALL (k: nat): FORALL (f: rfunc(k)):
    prim_rec?(k)(f) IMPLIES
      EXISTS (c: nat): FORALL (n: nat_args(k)): f(n) < ack(c, max_nats(k)(n))

% nat_args version of the Theorem above
pr_maj_by_ack_arr: THEOREM
  FORALL (k: nat): FORALL (f: rfunc(k)):
    prim_rec?(k)(f) IMPLIES
      EXISTS (c: nat): FORALL (n: nat_args(k)):
        f(n) < ack_arr(init_nats(2) WITH [0 := c, 1 := max_nats(k)(n)])

% Contradiction Theorem & associated Lemmas
% ----------------------------------------------

% F(x) = A(x, x)
ack_arr_diag(x: nat_args(1)): nat
  = compose(2, 1)(ack_arr, init_rfuncs(2, 1) WITH [0 := pi(1, 1), 1 := pi(1, 1)])(x)

% A in PR => F in PR
ack_pr_implies_diag_pr: LEMMA
  prim_rec?(2)(ack_arr) IMPLIES prim_rec?(1)(ack_arr_diag)

% Technical Helper Lemma used in the Theorem 
contradiction_arg_lemma: LEMMA
  FORALL (c: nat):
      (LAMBDA (i: Index[2]): 0) WITH [(0) := c, (1) := c]
    = LAMBDA (i: Index[2]):
        init_rfuncs(2, 1) WITH [(0) := pi(1, 1), (1) := pi(1, 1)](i)
	((LAMBDA (i: Index[1]): 0) WITH [(0) := c])

% A in PR => EXISTS c: F(c) < F(c) (CONTRADICTION)
ack_prim_rec_diag_contradiction: THEOREM
  prim_rec?(2)(ack_arr) IMPLIES EXISTS (c: nat):
    ack_arr_diag(init_nats(1) WITH [0 := c]) < ack_arr_diag(init_nats(1) WITH [0 := c])

% Main Theorem (proven by Contradiction Theorem)
% ----------------------------------------------

% A not_in PR
ack_not_prim_rec: THEOREM
  NOT prim_rec?(2)(ack_arr)

END pr_ack
