pr_ack: THEORY
BEGIN

  % ASSUMING
   % assuming declarations
  % ENDASSUMING

IMPORTING structures@arrays, structures@for_iterate

% Type aliases
nat_args(k: nat): TYPE+ = ArrayOf[k][nat]
rfunc(k: nat): TYPE+ = [nat_args(k) -> nat]

% Array helpers
sub_args(k: nat, u: below(k), l: upto(u))(a: nat_args(k)): nat_args(u-l+1)
  = IF
      u = l
    THEN
      init
    ELSE
      for[nat_args(u-l+1)]
      (0, u-l, init, LAMBDA(i: subrange(0, u-l), m: nat_args(u-l+1)):
        m WITH [`i := a(i+l)])
    ENDIF

expand_args(k: nat, j: nat)(a: nat_args(k)): nat_args(k+j)
  = for[nat_args(k+j)]
    (0, k-1, init, LAMBDA(i: subrange(0, k-1), r: nat_args(k+j)):
      r WITH [`i := a(i)])

% Base functions
zero(k: nat)(a: nat_args(k)): nat = 0

pr_succ(a: nat_args(1)): nat = a(0) + 1

pi(k: nat, i: below(k))(a: nat_args(k)): nat = a(i)
%pi(k: nat, i: below(k)): rfunc(k)
%  = LAMBDA (a: nat_args(k)): a(i)

% Operators

% for loop
% n: ArrayOf[k][nat]
% h: ArrayOf[r][rfunc(k)]
% m: ArrayOf[r][nat] = {0, ..., 0}
% for(i=1; i<= n; i++) {
%   m(i-1) = h(i-1)(n)
% }

% COMPOSITION
comp_build_m(r: nat, k: nat)(h: ArrayOf[r][rfunc(k)], n: nat_args(k)): nat_args(r)
  = for[nat_args(r)]
    (0, r-1, init, LAMBDA(i: subrange(0, r-1), m: nat_args(r)):
      m WITH [`i := h(i)(n)])

compose(r: nat, k: nat)(g: rfunc(r), h: ArrayOf[r][rfunc(k)]):
  rfunc(k) = (LAMBDA (n: nat_args(k)): g(comp_build_m(r, k)(h, n)))

% PRIMITIVE RECURSION OPERATOR

% for loop
% ns: ArrayOf[k+1][nat]
% m: ArrayOf[k][nat] = {0, ..., 0}
% for(i=0; i<=k-1; i++) {
%  m(i) = ns(i)
% }

pr_build_h_m(k: nat)(n: nat_args(k+1), f_prev: nat): nat_args(k+2)
  = LET j = k+1 IN expand_args(k+1, 1)(n) WITH [`k := n(k)-1] WITH [`j := f_prev]

pr(k: nat, g:rfunc(k), h:rfunc(k+2))(n: nat_args(k+1)): RECURSIVE nat
  = IF
      n(k) = 0
    THEN
      IF k = 0 THEN g(init) ELSE g(sub_args(k+1, k-1, 0)(n)) ENDIF
    ELSE
      h(pr_build_h_m(k)(n, pr(k, g, h)(n WITH [`k := n(k)-1])))
    ENDIF MEASURE n(k)


% ADDITION

%g_add(n: nat_args(1)): nat = pi(1, 1)(n)
%h_add(n: nat_args(3)): nat = compose(1, 3)(pr_succ, init_with[rfunc(3)] WITH [`0 := pi(3, 3)])(n)



%PREC: TYPE+

%zero_in_prec: AXIOM


END pr_ack
