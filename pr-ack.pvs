pr_ack: THEORY
BEGIN

  % ASSUMING
   % assuming declarations
  % ENDASSUMING

IMPORTING structures@arrays, structures@for_iterate

% Type aliases
nat_args(k: nat): TYPE+ = ArrayOf[k][nat]
rfunc(k: nat): TYPE+ = [nat_args(k) -> nat]

% Array helpers
% Mit WHERE reihenfolge der argumente verbessern (dieser Versuch funtkioniert nicht)
%sub_args(k: nat, l, u)(a: nat_args(k)): nat_args(u-l+1)

sub_args(k: nat, u: below(k), l: upto(u))(a: nat_args(k)): nat_args(u-l+1)
  =  for[nat_args(u-l+1)]
     (0, u-l, init, LAMBDA(i: subrange(0, u-l), m: nat_args(u-l+1)):
       m WITH [`i := a(i+l)])

expand_args(k: nat, j: nat)(a: nat_args(k)): nat_args(k+j)
  = for[nat_args(k+j)]
    (0, k-1, init, LAMBDA(i: subrange(0, k-1), r: nat_args(k+j)):
      r WITH [`i := a(i)])

% Base functions
zero(k: nat)(a: nat_args(k)): nat = 0

pr_succ(a: nat_args(1)): nat = a(0) + 1

pi(k: nat, i: upto(k))(a: nat_args(k+1)): nat = a(i)
%pi(k: nat, i: below(k)): rfunc(k)
%  = LAMBDA (a: nat_args(k)): a(i)

% Operators

% for loop
% n: ArrayOf[k][nat]
% h: ArrayOf[r][rfunc(k)]
% m: ArrayOf[r][nat] = {0, ..., 0}
% for(i=1; i<= n; i++) {
%   m(i-1) = h(i-1)(n)
% }

% COMPOSITION
comp_build_m(r: nat, k: nat)(h: ArrayOf[r][rfunc(k)], n: nat_args(k)): nat_args(r)
  = for[nat_args(r)]
    (0, r-1, init, LAMBDA(i: subrange(0, r-1), m: nat_args(r)):
      m WITH [`i := h(i)(n)])

compose(r: nat, k: nat)(g: rfunc(r), h: ArrayOf[r][rfunc(k)]):
  rfunc(k) = (LAMBDA (n: nat_args(k)): g(comp_build_m(r, k)(h, n)))

% PRIMITIVE RECURSION OPERATOR

% for loop
% ns: ArrayOf[k+1][nat]
% m: ArrayOf[k][nat] = {0, ..., 0}
% for(i=0; i<=k-1; i++) {
%  m(i) = ns(i)
% }

% Kann man noch besser schreiben durch WITH [(k) := n(k)-1, (k+1) := f_prev]
pr_build_h_m(k: nat)(n: nat_args(k+1), f_prev: nat): nat_args(k+2)
  = LET j = k+1 IN expand_args(k+1, 1)(n) WITH [`k := n(k)-1] WITH [`j := f_prev]

pr(k: nat, g:rfunc(k), h:rfunc(k+2))(n: nat_args(k+1)): RECURSIVE nat
  = IF
      n(k) = 0
    THEN
      IF k = 0 THEN g(init) ELSE g(sub_args(k+1, k-1, 0)(n)) ENDIF
    ELSE
      h(pr_build_h_m(k)(n, pr(k, g, h)(n WITH [`k := n(k)-1])))
    ENDIF MEASURE n(k)


% ADDITION

g_add: rfunc(1) = pi(0, 0)
pi_arr_add: ArrayOf[1][rfunc(3)] = init_with[1][rfunc(3)](pi(2, 2))
h_add: rfunc(3) = compose(1, 3)(pr_succ, pi_arr_add)
pr_add_arr(n: nat_args(2)): nat = pr(1, g_add, h_add)(n)

add_help_args(n: nat, m: nat): [Index[2] -> nat] = LAMBDA (i: Index[2]):
  IF i = 0 THEN n ELSIF i = 1 THEN m ELSE 0 ENDIF
pr_add(n: nat, m: nat): nat = pr_add_arr(add_help_args(n, m))

% FRAGE AN GESER: Wie kann man dieses Lemma beweisen?
addition_args: LEMMA
  FORALL (j: nat): (FORALL (n: nat): (FORALL (m: nat):
    add_help_args(n, j) = add_help_args(n, m) WITH [(1) := j]
  ))

pr_add_is_addition: FORMULA
  FORALL (n: nat): (FORALL (m: nat): pr_add(n, m) = n + m)

%PREC: TYPE+

%zero_in_prec: AXIOM


END pr_ack
