pr_ack: THEORY
BEGIN
IMPORTING structures@arrays, structures@max_array

% TYPE DEFINITIONS AND HELPER FUNCTIONS
% ################################################################################

% Type aliases
nat_args(k: nat): TYPE+ = ArrayOf[k][nat]
rfunc(k: nat): TYPE+ = [nat_args(k) -> nat]

% Custom array init functions
% - These are defined here because the structures@arrays builtin
%   initializer functions sometimes crash the typechecker
copy_init(k: nat, l: upto(k))(a: nat_args(k)): nat_args(l)
  = LAMBDA (i: Index[l]): a(i)

copy_init_rfunc(r: nat, l: upto(r), k: nat)(a: ArrayOf[r][rfunc(k)]): ArrayOf[l][rfunc(k)]
  = LAMBDA (i: Index[l]): a(i)

init_nats(k: nat): nat_args(k) = LAMBDA (i: Index[k]): 0

max_nats(k: nat)(a: nat_args(k)): nat =
  IF k = 0
  THEN 0
  ELSE max[k, nat, <=](a)
  ENDIF

init_rfuncs(r: nat, k: nat): ArrayOf[r][rfunc(k)]
  = LAMBDA (i: Index[r]): LAMBDA (n: nat_args(k)): 0

% PRIMITIVE RECURSIVE FUNCTION DEFINITIONS
% ################################################################################

% Base functions
zero(k: nat)(a: nat_args(k)): nat = 0

pr_succ(a: nat_args(1)): nat = a(0) + 1

pi(k: posnat, i: subrange(1, k))(a: nat_args(k)): nat = a(i-1)

% Operators
% -------------------------------------------------------------------------------

% Composition
compose(r: posnat, k: nat)(g: rfunc(r), h: ArrayOf[r][rfunc(k)]):
  rfunc(k) = (LAMBDA (n: nat_args(k)): g(LAMBDA (i: Index[r]): h(i)(n)))

% -------------------------------------------------------------------------------

% Primitive Recursion
pr(k: nat, g:rfunc(k), h:rfunc(k+2))(n: nat_args(k+1)): RECURSIVE nat
  = IF
      n(k) = 0
    THEN
      IF k = 0 THEN g(init) ELSE g(copy_init(k+1, k)(n)) ENDIF
    ELSE
       LET m = n WITH [k := n(k)-1]
       IN h(m WITH [(k+1) |-> pr(k, g, h)(m)])
    ENDIF MEASURE n(k)

% -------------------------------------------------------------------------------


% EXAMPLES: ARITHMETIC FUNCTIONS AS PR-FUNCTIONS
% ################################################################################

% ADDITION
% -------------------------------------------------------------------------------

% PR-Arguments g, h
g_add: rfunc(1) = pi(1, 1)
% Typechecker crashes if h is initialized inline by init_with
h_add_pi_arr: ArrayOf[1][rfunc(3)] = init_with[1][rfunc(3)](pi(3, 3)) 
h_add: rfunc(3) = compose(1, 3)(pr_succ, h_add_pi_arr)

% PR-Addition
pr_add_arr(n: nat_args(2)): nat = pr(1, g_add, h_add)(n)
pr_add(n: nat, m: nat): nat = pr_add_arr(init_nats(2) WITH [0 := n, 1 := m])

% Lemmata and Theorems
addition_args: LEMMA
  FORALL (j: nat): (FORALL (n: nat): (FORALL (m: nat):
     init_nats(2) WITH [0 := n, 1 := j] = (init_nats(2) WITH [0 := n, 1 := m]) WITH [1 := j]
  ))

arr_helper_lemma: LEMMA
  FORALL (a: nat_args(2)):
    a(1) > 0 IMPLIES (a WITH [1 := a(1)-1]) = (init_nats(2) WITH [0 := a(0), 1 := a(1) - 1])

% REDO SOME PROOF STEPS BECAUSE OF CHANGED DEFINITIONS
pr_add_is_addition: FORMULA
  FORALL (n: nat): (FORALL (m: nat): pr_add(n, m) = n + m)

pr_add_arr_is_addition: FORMULA
  FORALL (a: nat_args(2)): pr_add_arr(a) = a(0) + a(1)

% MULTIPLICATION
% -------------------------------------------------------------------------------

g_mult: rfunc(1) = zero(1)
pi_arr_mult: ArrayOf[2][rfunc(3)] = init_with[2][rfunc(3)](pi(3,1)) WITH [1 := pi(3,3)]
h_mult: rfunc(3) = compose(2, 3)(pr_add_arr, pi_arr_mult)
pr_mult(n: nat, m: nat): nat = pr(1, g_mult, h_mult)(init_nats(2) WITH [0 := n, 1 := m])


pr_mult_is_multiplication: FORMULA
   FORALL (n: nat): (FORALL (m: nat): pr_mult(n, m) = n * m)


% DEFINITION: SET OF PRIMITIVE RECURSIVE FUNCTIONS
% ################################################################################

% k-ary PR-Functions predicate
prim_rec?(k: nat)(f: rfunc(k)): INDUCTIVE bool =
     (f = zero(k))
  OR (k = 1 AND f = pr_succ)
  OR (EXISTS (i: subrange(1, k)): f = pi(k, i))
  OR (EXISTS (r: posnat): (EXISTS (g: rfunc(r)): (EXISTS (h: [Index[r] -> rfunc(k)]):
       prim_rec?(r)(g)
       AND (FORALL (i: Index[r]): prim_rec?(k)(h(i)))
       AND f = compose(r, k)(g, h))))
  OR ((k > 0) AND (EXISTS (g: rfunc(k-1)): (EXISTS (h: rfunc(k+1)):
     prim_rec?(k-1)(g) AND prim_rec?(k+1)(h) AND f = pr(k-1, g, h))))

prim_rec(k: nat): TYPE+ = (prim_rec?(k)) CONTAINING zero(k)

%prim_rec_preds: setofsets = {p | EXISTS (k: nat): p = prim_rec?(k)}

%test: TYPE = { (x: nat) | x = 3 }

%prim_rec: TYPE+ = { (FORALL (k: nat): (f: rfunc(k)) | prim_rec?(k)(f)) }

%PREC: TYPE+
%zero_in_prec: AXIOM


% ACKERMANN FUNCTION
% ################################################################################

% FUNCTION DEFINITION
% -------------------------------------------------------------------------------

ack(x: nat, y: nat): RECURSIVE nat =
  IF x = 0
  THEN y + 1
  ELSIF y = 0
  THEN ack(x-1, 1)
  ELSE ack(x-1, ack(x, y-1))
  ENDIF MEASURE lex2(x, y)


% LEMMATA
% -------------------------------------------------------------------------------

% Prop 4: y < A(x, y)
% ----------------------------------------------
ack_prop4: LEMMA
  FORALL (x: nat): FORALL (y: nat): y < ack(x, y)

% Prop 5: Monotonicity in y
%   y < y_ => A(x, y) < A(x, y_)
% ----------------------------------------------
ack_prop5_base: LEMMA
  FORALL (x: nat): FORALL (y: nat): ack(x, y) < ack(x, y + 1)

ack_prop5_diff: LEMMA
  FORALL (d: nat): FORALL (x, y, y_: nat): y_ = y + (d + 1) IMPLIES ack(x, y) < ack(x, y_)

ack_prop5: LEMMA
  FORALL (x: nat): FORALL (y: nat): FORALL (y_: nat): y < y_ IMPLIES ack(x, y) < ack(x, y_)

% Prop 6: A(x, y+1) <= A(x+1, y)
% ----------------------------------------------
ack_prop6: LEMMA
  FORALL (x: nat): FORALL (y: nat): ack(x, y + 1) <= ack(x + 1, y) 

% Prop 7: Monotonicity in x
%   x < x_ => A(x, y) < A(x_, y)
% ----------------------------------------------
ack_prop7_base: LEMMA
  FORALL (x: nat): FORALL (y: nat): ack(x, y) < ack(x + 1, y)

ack_prop7_diff: LEMMA
  FORALL (d: nat): FORALL (x, x_, y: nat): x_ = x + (d + 1) IMPLIES ack(x, y) < ack(x_, y)

ack_prop7: LEMMA
  FORALL (x: nat): FORALL (x_: nat): FORALL (y: nat): x < x_ IMPLIES ack(x, y) < ack(x_, y)

% Prop 8: A(1, y) = y + 2
% ----------------------------------------------
ack_prop8: LEMMA
  FORALL (y: nat): ack(1, y) = y + 2

% Prop 9: A(2, y) = 2y + 3
% ----------------------------------------------
ack_prop9: LEMMA
  FORALL (y: nat): ack(2, y) = 2 * y + 3

% Prop 10: EXISTS k: A(x, A(x_, y)) < A(k, y)
% ----------------------------------------------
ack_prop10: LEMMA
  FORALL (x, x_: nat): EXISTS (k: nat): FORALL (y: nat): ack(x, ack(x_, y)) < ack(k, y)

ack_prop10_constant: LEMMA
  FORALL (x, x_, y: nat): ack(x, ack(x_, y)) < ack(x + x_ + 2, y)


% THEOREMS
% -------------------------------------------------------------------------------

% Majorization Theorems
% ----------------------------------------------

% nat_args version of the Ackermann function
ack_arr(n: nat_args(2)): nat = ack(n(0), n(1))

% Majorization Predicate
maj_by_ack?(k: nat)(f: rfunc(k)): bool
  = EXISTS (c: nat): FORALL (n: nat_args(k)): f(n) < ack(c, max_nats(k)(n))

% Lemma used to show TCC for maj_constants_array
maj_by_ack_implies_maj_const_existance: LEMMA
  FORALL (k: nat): FORALL (f: rfunc(k)):
    maj_by_ack?(k)(f) IMPLIES EXISTS (c: nat): FORALL (n: nat_args(k)): f(n) < ack(c, max_nats(k)(n)) 

% nat_args version of the Majorization Prediacte
maj_by_ack_arr?(k: nat)(f: rfunc(k)): bool
  = EXISTS (c: nat): FORALL (n: nat_args(k)):
      f(n) < ack_arr(init_nats(2) WITH [0 := c, 1 := max_nats(k)(n)])

% Inductive steps to show majorization

% 1: Zero
pr_zero_maj_by_ack: THEOREM
  FORALL (k: nat, f: rfunc(k)): f = zero(k) IMPLIES maj_by_ack?(k)(f)

% 2: Succ
pr_succ_maj_by_ack: THEOREM
  FORALL (k: nat, f: rfunc(k)): (k = 1 AND f = pr_succ) IMPLIES maj_by_ack?(k)(f) 

% 3: Projection
pr_pi_maj_by_ack: THEOREM
  FORALL (k: nat, f: rfunc(k)): (EXISTS (i: subrange(1, k)): f = pi(k, i)) IMPLIES maj_by_ack?(k)(f)

% 4: Composition
% ----------------------------------------------

% Helper function used in the majorization proof
maj_by_ack(k: nat): TYPE+ = (maj_by_ack?(k)) CONTAINING zero(k)

maj_by_ack_constant?(k: nat)(f: maj_by_ack(k))(c: nat): bool
  = FORALL (n: nat_args(k)): f(n) < ack(c, max_nats(k)(n))

maj_constant_min(k: nat)(f: maj_by_ack(k)): nat
  = min(maj_by_ack_constant?(k)(f))

% Choose constants for an array of majorized h_i
maj_constants_array(r: posnat, k: nat)(h: [Index[r] -> maj_by_ack(k)]): nat_args(r)
%  = LAMBDA (i: Index[r]): choose(maj_by_ack_constant?(k)(h(i)))
  = LAMBDA (i: Index[r]): maj_constant_min(k)(h(i))

% Helper lemma for the following lemma
% maj_by_ack_constant?(k)(f)(c) IMPLIE
maj_constant_ineq: LEMMA
  FORALL (k: nat, f: maj_by_ack(k), c: nat):
    maj_by_ack_constant?(k)(f)(c) IMPLIES FORALL (n: nat_args(k)): f(n) < ack(c, max_nats(k)(n))

% Helper lemma used in Composition proof:
%   If an array h of functions has majorization constants
%   there exists a universal majorization constant
%   majorizing all the functions
universal_maj_constant: LEMMA
  FORALL (r: posnat): FORALL (k: nat): FORALL (h: [Index[r] -> maj_by_ack(k)]):
      (FORALL (i: Index[r]): maj_by_ack?(k)(h(i)))
    IMPLIES
      (EXISTS (c: nat): FORALL (i: Index[r]): maj_by_ack_constant?(k)(h(i))(c))

% Main Proof: Composition is majorized
pr_comp_maj_by_ack: THEOREM
  FORALL (k: nat, f: rfunc(k)):
    (EXISTS (r: posnat): (EXISTS (g: rfunc(r)): (EXISTS (h: [Index[r] -> rfunc(k)]):
      maj_by_ack?(r)(g) AND (FORALL (i: Index[r]): maj_by_ack?(k)(h(i))) AND f = compose(r, k)(g, h))))
    IMPLIES maj_by_ack?(k)(f)

% 5: Primitive Recursion
% ----------------------------------------------

% Helper Lemma used for the mixed version
remove_appended_el_eq: LEMMA
  FORALL (k: nat): FORALL (n: nat_args(k)): FORALL (x: nat):
    copy_init(k+1, k)(n WITH [k |-> x]) = n

% Helper lemma used after the mixed version
split_at_last_eq: LEMMA
  FORALL (k: nat, n: nat_args(k+1)):
    n = copy_init(k+1, k)(n) WITH [k |-> n(k)]

% Helper Lemma used for the mixed version
max_ab_le_sum: LEMMA
  FORALL (a, b: nat): max(a, b) <= a + b

% Helper Lemma for max_expanded
max_append_smaller: LEMMA
  FORALL (k: nat, n: nat_args(k)):
    FORALL (a: nat):
      a < max_nats(k)(n) IMPLIES max_nats(k)(n) = max_nats(k+1)(n WITH [k |-> a])
      
% Helper Lemma used for the mixed version
max_expanded_n_eq: LEMMA
  FORALL (k: nat, n: nat_args(k)):
    FORALL (a: nat):
      max_nats(k+1)(n WITH [k |-> a]) = max(max_nats(k)(n), a)

% Helper Lemma
max_expanded2_n_eq: LEMMA
  FORALL (k: nat, n: nat_args(k)):
    FORALL (a, b: nat):
      max_nats(k+2)(n WITH [k |-> a, (k+1) |-> b]) = max(max(max_nats(k)(n), a), b)

% Helper Lemma, mixed version
% f = pr(k-1, g, h) => EX c: ALL m = (n:i): f(m) < A(c, n + i)
pr_rec_maj_by_ack_inductive_part_mixed: LEMMA
  FORALL (k: nat, f: rfunc(k)):
    ((k > 0) AND (EXISTS (g: rfunc(k - 1)): (EXISTS (h: rfunc(k + 1)):
      maj_by_ack?(k - 1)(g) AND maj_by_ack?(k + 1)(h) AND f = pr(k - 1, g, h))))
    IMPLIES
      EXISTS (c: nat): FORALL (n: nat_args(k-1)): FORALL (x: nat):
        f(n WITH [(k-1) |-> x]) < ack(c, x + max_nats(k-1)(n))


% Helper Lemma
% f = pr(k-1, g, h) => EX c: ALL m = (n:i): f(m) < A(c, n + i)
%pr_rec_maj_by_ack_inductive_part: LEMMA
%  FORALL (k: nat, f: rfunc(k)):
%    ((k > 0) AND (EXISTS (g: rfunc(k - 1)): (EXISTS (h: rfunc(k + 1)):
%      maj_by_ack?(k - 1)(g) AND maj_by_ack?(k + 1)(h) AND f = pr(k - 1, g, h))))
%    IMPLIES
%      EXISTS (c: nat): FORALL (n: nat_args(k)):
%        f(n) < ack(c, n(k-1) + max_nats(k-1)(copy_init(k, k-1)(n)))

% Main Proof, mixed version
%pr_rec_maj_by_ack_mixed: THEOREM
  

% Main Proof: Primitive recursion is majorized
pr_rec_maj_by_ack: THEOREM
  FORALL (k: nat, f: rfunc(k)):
    ((k > 0) AND (EXISTS (g: rfunc(k - 1)): (EXISTS (h: rfunc(k + 1)):
      maj_by_ack?(k - 1)(g) AND maj_by_ack?(k + 1)(h) AND f = pr(k - 1, g, h))))
    IMPLIES maj_by_ack?(k)(f)


% MAIN THEOREM: Proof by contradiction
% ----------------------------------------------

pr_maj_lemma_weak_ind_antecedent: LEMMA
  FORALL (k: nat, f: rfunc(k)):
       (f = zero(k)) OR (k = 1 AND f = pr_succ)
    OR (EXISTS (i: subrange(1, k)): f = pi(k, i))
    OR (EXISTS (r: posnat): (EXISTS (g: rfunc(r)): (EXISTS (h: [Index[r] -> rfunc(k)]):
         maj_by_ack?(r)(g) AND (FORALL (i: Index[r]): maj_by_ack?(k)(h(i))) AND f = compose(r, k)(g, h))))
    OR ((k > 0) AND (EXISTS (g: rfunc(k - 1)): (EXISTS (h: rfunc(k + 1)):
         maj_by_ack?(k - 1)(g) AND maj_by_ack?(k + 1)(h) AND f = pr(k - 1, g, h))))
    IMPLIES maj_by_ack?(k)(f)

% FORALL f in PR: EXISTS c: FORALL n:
%   f(n) < A(c, max(n))
pr_maj_by_ack: THEOREM
  FORALL (k: nat): FORALL (f: rfunc(k)):
    prim_rec?(k)(f) IMPLIES maj_by_ack?(k)(f)

% nat_args version of the Theorem above
pr_maj_by_ack_arr: THEOREM
  FORALL (k: nat): FORALL (f: rfunc(k)):
    prim_rec?(k)(f) IMPLIES maj_by_ack_arr?(k)(f)      

% Contradiction Theorem & associated Lemmas
% ----------------------------------------------

% F(x) = A(x, x)
ack_arr_diag(x: nat_args(1)): nat
  = compose(2, 1)(ack_arr, init_rfuncs(2, 1) WITH [0 := pi(1, 1), 1 := pi(1, 1)])(x)

% A in PR => F in PR
ack_pr_implies_diag_pr: LEMMA
  prim_rec?(2)(ack_arr) IMPLIES prim_rec?(1)(ack_arr_diag)

% Technical Helper Lemma used in the Theorem 
contradiction_arg_lemma: LEMMA
  FORALL (c: nat):
      (LAMBDA (i: Index[2]): 0) WITH [(0) := c, (1) := c]
    = LAMBDA (i: Index[2]):
        init_rfuncs(2, 1) WITH [(0) := pi(1, 1), (1) := pi(1, 1)](i)
	((LAMBDA (i: Index[1]): 0) WITH [(0) := c])

% A in PR => EXISTS c: F(c) < F(c) (CONTRADICTION)
ack_prim_rec_diag_contradiction: THEOREM
  prim_rec?(2)(ack_arr) IMPLIES EXISTS (c: nat):
    ack_arr_diag(init_nats(1) WITH [0 := c]) < ack_arr_diag(init_nats(1) WITH [0 := c])

% Main Theorem (proven by Contradiction Theorem)
% ----------------------------------------------

% A not_in PR
ack_not_prim_rec: THEOREM
  NOT prim_rec?(2)(ack_arr)

END pr_ack
